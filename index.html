<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="stylesheet" href="style.css">
  <title>Decor EdgeLabel ‚Äî Filament Configurator (ui2 + stretch fix)</title>

  <!-- Import map for bare specifiers -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
    }
  }
  </script>


</head>
<body>
  <div class="app">
    <!-- CONTROLS: keep only ONE .panel (this <aside>) -->
    <aside class="panel" id="controls">
      <div class="title">Decor EdgeLabel ‚Äî Filament Configurator</div>
      <div class="muted">Swappable accent GLBs. Base: <code>edgelabel.glb</code>.</div>

      <div class="field">
        <label>Preset combos</label>
        <div id="presetChips" class="chips"></div>
      </div>
      <hr class="hr"/>



<!-- Faceplate -->
<div class="field">
  <label>Faceplate filament</label>
  <div class="control-row">
    <span id="swatchFace" class="swatch"></span>
    <select id="faceSelect"></select>
    <button class="mini" data-picker-for="faceSelect" title="Pick by brand & color">‚ñæ</button>
    <button id="buyFace" class="mini">üõí</button>
  </div>
</div> <!-- ‚Üê this closing div was missing -->
<!-- Backer -->
<div class="field">
  <label>Backer color</label>
  <div class="control-row">
    <span id="swatchBacker" class="swatch"></span>
    <select id="backerSelect"></select>
    <button class="mini" data-picker-for="backerSelect" title="Pick by brand & color">‚ñæ</button>
    <button id="buyBacker" class="mini">üõí</button>
  </div>
</div>
      <!-- Label -->
       <div class="field">
         <label>Label color</label>
         <div class="control-row">
           <span id="swatchLabel" class="swatch"></span>
            <select id="labelSelect"></select>
           <button class="mini" data-picker-for="labelSelect" title="Pick by brand & color">‚ñæ</button>
            <button id="buyLabel" class="mini">üõí</button>
          </div>
        </div>
      <!-- Text -->
       <div class="field">
         <label>Text color</label>
         <div class="control-row">
           <span id="swatchText" class="swatch"></span>
            <select id="textSelect"></select>
           <button class="mini" data-picker-for="textSelect" title="Pick by brand & color">‚ñæ</button>
            <button id="buytext" class="mini">üõí</button>
          </div>
        </div>





      <hr class="hr"/>

      <!-- Accent controls -->
      <div class="field">
        <label>Accent style</label>
        <select id="accentStyle">
          <option value="original">Original</option>
          <option value="slat">Slat</option>
        </select>
      </div>

      <div>
        <div class="field">
          <label>Accent color (material: ‚ÄúAccent‚Äù)</label>
          <div class="control-row">
            <span id="swatchAccent" class="swatch"></span>
            <select id="accentSelect"></select>
            <button id="buyAccent" class="mini">Buy</button>
            <a id="accentPrintables" class="mini" href="#" target="_blank" rel="noopener">Printables</a>
          </div>
        </div>

        <div class="field" id="accentTwoWrap" style="display:none">
          <label>Second accent color (material: ‚ÄúAccent_2‚Äù)</label>
          <div class="control-row">
            <span id="swatchAccent2" class="swatch"></span>
            <select id="accent2Select"></select>
            <button id="buyAccent2" class="mini">Buy</button>
          </div>
        </div>
      </div>
    </aside>

    <!-- VIEWER: keep exactly one canvas -->
    <main class="viewer-wrap">
      <canvas id="viewer"></canvas>
    </main>
  </div>











  <div id="status" class="status ok"></div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  const ASSET_PATH = './';
  const STATUS = document.getElementById('status');
  function status(msg, isError=true){ STATUS.classList.remove('ok'); STATUS.textContent = msg; (isError?console.error:console.log)(msg); }

  // UI handles
  const $ = (q)=>document.querySelector(q);
  const canvas = document.getElementById('viewer'); const chipsWrap = $('#presetChips');
  const faceSel      = $('#faceSelect');  const accentSel = $('#accentSelect');
  const backerSel    = $('#backerSelect');const labelSel  = $('#labelSelect');
  const textSel      = $('#textSelect');
  const accentStyle  = $('#accentStyle');
  const swFace = $('#swatchFace'), swAccent = $('#swatchAccent'), swBacker = $('#swatchBacker'), swLabel=$('#swatchLabel'), swAccent2=$('#swatchAccent2'), swText= $('#swatchText');
  const accent2Wrap = $('#accentTwoWrap'); const accent2Sel = $('#accent2Select');
  const resetBtn = $('#reset'); const copyURL = $('#copyURL');
  const frameBaseBtn = $('#frameBase'); const frameAllBtn = $('#frameAll'); const axesToggleBtn = $('#axesToggle');

  // Scene
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(35, 1, 0.01, 1000);
  camera.position.set(0.25, 0.25, 0.6);
  const controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true;

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0); hemi.position.set(0, 1, 0); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.6); dir.position.set(3, 5, 4); scene.add(dir);

  const loader = new GLTFLoader();

  // Model roots
  let baseRoot=null, accentRoot=null, accentAnchor=null;
  let axesHelper=null;

  // Filaments (fallback palette + presets)
  let FILAMENTS = [
    { id:'basic-black', brand:'Generic', name:'Black', hex:'#1a1a1a', metallic:0.0, roughness:0.6 },
    { id:'basic-white', brand:'Generic', name:'White', hex:'#eeeeee', metallic:0.0, roughness:0.5 },
    { id:'silver-silk', brand:'Generic', name:'Silver', hex:'#c0c0c0', metallic:0.6, roughness:0.3 },
    { id:'gold-silk', brand:'Generic', name:'Gold', hex:'#d9b245', metallic:0.7, roughness:0.35 },
    { id:'slate', brand:'Generic', name:'Slate', hex:'#4b5563', metallic:0.1, roughness:0.55 }
  ];

  let PRESETS = [];

  async function loadPresets() {
    try {
      const res = await fetch("presets.json");
      PRESETS = await res.json();
      buildPresetChips(); // re-render once loaded
    } catch (err) {
      console.error("Failed to load presets.json", err);
    }
  }

  function buildPresetChips() {
    chipsWrap.innerHTML = "";
    PRESETS.forEach(preset => {
      const btn = document.createElement("button");
      btn.textContent = preset.name || preset.title || preset.id;
      btn.className = "chip";
      btn.onclick = () => applyPreset(preset);
      chipsWrap.appendChild(btn);
    });
  }

  // -------- Build all <select>s from FILAMENTS (module scope; single definition) --------
function populateSelectors(){
  const ids = ['faceSelect','backerSelect','labelSelect','textSelect','accentSelect','accent2Select'];
  const data = window.FILAMENTS || [];
  ids.forEach(id => {
    const sel = document.getElementById(id);
    if (!sel) return;
    sel.innerHTML = '';

    // optional placeholder
    // const opt0 = document.createElement('option');
    // opt0.value = '';
    // opt0.textContent = 'Select filament‚Ä¶';
    // sel.appendChild(opt0);

    data.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f.id;
      const brand  = f.brand ? `${f.brand} ‚Äî ` : '';
      const finish = f.finish ? ` (${f.finish})` : '';
      opt.textContent = `${brand}${f.name}${finish}`;   // <- what closed select shows
      opt.dataset.hex = f.hex || '';
      opt.dataset.metallic = f.metallic ?? 0.0;
      opt.dataset.roughness = f.roughness ?? 0.6;
      sel.appendChild(opt);
    });
  });
}


  function attachAllPickers(){
    ['faceSelect','backerSelect','labelSelect','textSelect','accentSelect','accent2Select']
      .forEach(id => window.attachFilamentPicker?.(id));
  }

  async function loadFilaments(){
    try{
      const res = await fetch('filaments.json', { cache: 'no-cache' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const data = await res.json();

      // keep local + global in sync so both viewer and picker see the same array
      FILAMENTS = Array.isArray(data) ? data : [];
      window.FILAMENTS = FILAMENTS;

      // build menus
      populateSelectors();

      // ensure each select has an initial value
      ['faceSelect','backerSelect','labelSelect','textSelect','accentSelect','accent2Select'].forEach(id=>{
        const sel = document.getElementById(id);
        if (sel && !sel.value && sel.options.length) sel.value = sel.options[0].value;
      });

      // attach the custom picker (may be defined later, so we call again on window 'load' below)
      attachAllPickers();

      // hide native selects after the picker is wired
      //['faceSelect','backerSelect','labelSelect','textSelect','accentSelect','accent2Select']
      //  .forEach(id => document.getElementById(id)?.classList.add('visually-hidden'));

      applyCurrentSelection();
      refreshAllBuyButtons();
    }catch(err){
      console.error('Failed to load filaments.json', err);
      // still expose whatever exists so the picker isn‚Äôt empty
      window.FILAMENTS = FILAMENTS || [];
      populateSelectors();
    }
  }

  function applyPreset(preset) {
    if (preset.face)   faceSel.value   = resolveFilament(preset.face);
    if (preset.accent) accentSel.value = resolveFilament(preset.accent);
    if (preset.backer) backerSel.value = resolveFilament(preset.backer);
    if (preset.label)  labelSel.value  = resolveFilament(preset.label);
    if (preset.text)   textSel.value   = resolveFilament(preset.text);

    applyCurrentSelection();
    refreshAllBuyButtons();
    updateAccentPrintables();
  }

  // Resolve an id or fuzzy text to an existing FILAMENTS entry
  function resolveFilament(ref){
    if (!ref) return null;
    if (!Array.isArray(FILAMENTS) || FILAMENTS.length===0) return null;
    let hit = FILAMENTS.find(f=> (f.id||'').toLowerCase() === String(ref).toLowerCase());
    if (hit) return hit.id;
    const q = String(ref).trim().toLowerCase();
    hit = FILAMENTS.find(f=> (f.name||'').toLowerCase().includes(q) || (`${f.brand||''} ${f.name||''}`).toLowerCase().includes(q));
    if (hit) return hit.id;
    hit = FILAMENTS.find(f=> (f.hex||'').toLowerCase() === q);
    if (hit) return hit.id;
    return FILAMENTS[0].id;
  }

  function hexToThreeColor(hex){ const c=new THREE.Color(); try{ c.set(hex);}catch{ c.set('#ffffff'); } return c; }

  function applyFilamentToThree(root, matName, filament, {warnIfMissing=true}={}){
    if (!root || !filament) return;
    const color=hexToThreeColor(filament.hex);
    const metallic=Number(filament.metallic??0.0);
    const roughness=Number(filament.roughness??0.6);
    let hits=0;
    root.traverse(obj=>{
      if (obj.isMesh){
        const mats=Array.isArray(obj.material)?obj.material:[obj.material];
        for (const m of mats){
          if (!m) continue;
          const name=(m.name||'').toLowerCase();
          const target=matName.toLowerCase();
          if (name===target || name.startsWith(target)){
            if (!m.isMeshStandardMaterial){ obj.material=new THREE.MeshStandardMaterial({ name:m.name||matName }); }
            const mat=Array.isArray(obj.material)?obj.material[0]:obj.material;
            mat.color.copy(color); mat.metalness=metallic; mat.roughness=roughness; mat.needsUpdate=true; hits++;
          }
        }
      }
    });
    if (hits===0 && warnIfMissing){ status(`Material "${matName}" not found on ${root===baseRoot?'base':'accent'} model.`); }
  }

  function getFilamentById(fid){
    return (FILAMENTS||[]).find(f=>String(f.id).toLowerCase()===String(fid).toLowerCase()) || null;
  }

  function updateBuyButton(btnEl, selEl){
    if (!btnEl || !selEl) return;
    const val = selEl.value;
    const f = getFilamentById(val);
    const href = f && f.link ? f.link : null;
    btnEl.disabled = !href;
    btnEl.onclick = href ? () => window.open(href, '_blank', 'noopener') : null;
    btnEl.title = href ? `Open product page for ${f.brand||''} ${f.name||''}` : 'No link available';
  }

  function refreshAllBuyButtons(){
    updateBuyButton(document.getElementById('buyFace'),   document.getElementById('faceSelect'));
    updateBuyButton(document.getElementById('buyBacker'), document.getElementById('backerSelect'));
    updateBuyButton(document.getElementById('buyLabel'),  document.getElementById('labelSelect'));
    const txtSel = document.getElementById('textSelect'); if (txtSel) updateBuyButton(document.getElementById('buyText'), txtSel);
    updateBuyButton(document.getElementById('buyAccent'), document.getElementById('accentSelect'));
    const acc2Sel = document.getElementById('accent2Select'); if (acc2Sel) updateBuyButton(document.getElementById('buyAccent2'), acc2Sel);
  }

  // Update Printables link based on accent style
  function updateAccentPrintables(){
    const style = document.getElementById('accentStyle').value;
    const a = document.getElementById('accentPrintables');
    if (!a) return;
    a.href = (style === 'slat')
      ? 'https://www.printables.com/model/1374169-gen2-decor-faceplate-accent-slat'
      : 'https://www.printables.com/model/1093933-gen2-decor-faceplates-edgelabel-series';
    a.title = 'Open on Printables.com';
  }

  function paintSwatches(){
    const g = sel => sel.selectedOptions[0]?.dataset.hex || '#000';
    swFace.style.background=g(faceSel); swAccent.style.background=g(accentSel);
    swBacker.style.background=g(backerSel); swLabel.style.background=g(labelSel); swText.style.background=g(textSel); swAccent2.style.background=g(accent2Sel);
  }

  function bboxOf(obj){
    const box=new THREE.Box3().setFromObject(obj); const size=new THREE.Vector3(); const center=new THREE.Vector3();
    box.getSize(size); box.getCenter(center); return {box,size,center};
  }

  function fitCameraTo(object3D){
    if (!object3D) return;
    const {size,center}=bboxOf(object3D);
    const maxDim = Math.max(size.x,size.y,size.z);
    const fov = camera.fov * (Math.PI/180);
    const dist = (maxDim/2) / Math.tan(fov/2);
    camera.position.copy(center).add(new THREE.Vector3(dist*0.8, dist*0.8, dist*1.2));
    camera.lookAt(center);
    controls.target.copy(center);
    controls.update();
  }

  function normalizeScale(root){
    const {size}=bboxOf(root); const maxDim=Math.max(size.x,size.y,size.z)||1e-6;
    if (maxDim>5){ const scale=0.1/maxDim; root.scale.multiplyScalar(scale); }
    else if (maxDim<0.02){ const scale=0.2/Math.max(maxDim,1e-6); root.scale.multiplyScalar(scale); }
  }

  function disposeHierarchy(root){
    root.traverse(obj=>{
      if (obj.isMesh){
        obj.geometry?.dispose?.();
        const mats=Array.isArray(obj.material)?obj.material:[obj.material];
        mats.forEach(m=>{ if (!m) return; for (const k in m){ const v=m[k]; if (v && v.isTexture) v.dispose?.(); } m.dispose?.(); });
      }
    });
  }

  async function loadBase(){
    try{
      const glb = await loader.loadAsync(ASSET_PATH+'edgelabel.glb');
      baseRoot = glb.scene;
      normalizeScale(baseRoot);
      baseRoot.traverse(o=>{ if (o.isMesh){ o.castShadow=false; o.receiveShadow=false; } });
      scene.add(baseRoot);
      accentAnchor = baseRoot.getObjectByName('AccentAnchor') || null;
      fitCameraTo(baseRoot);
    }catch(e){ status('Failed to load '+ASSET_PATH+'edgelabel.glb ‚Äî '+e.message); }
  }

  async function loadAccent(style){
    if (accentRoot){ scene.remove(accentRoot); disposeHierarchy(accentRoot); accentRoot=null; }
    const file = (style === 'slat') ? 'accent_slat.glb' : 'accent_original.glb';
    try{
      const glb = await loader.loadAsync(ASSET_PATH+file);
      accentRoot = glb.scene;
      normalizeScale(accentRoot);
      if (accentAnchor){
        accentAnchor.updateWorldMatrix(true,true);
        accentRoot.matrix.copy(accentAnchor.matrixWorld);
        accentRoot.matrix.decompose(accentRoot.position, accentRoot.quaternion, accentRoot.scale);
      }
      accentRoot.traverse(o=>{
        if (o.isMesh){
          const m=o.material; if (Array.isArray(m)) return;
          if (m && !m.isMeshStandardMaterial){ o.material = new THREE.MeshStandardMaterial({ color:m.color||0x999999, metalness:0.1, roughness:0.6, name:m.name||'Accent' }); }
        }
      });
      scene.add(accentRoot);
      applyCurrentSelection();
    }catch(e){ status('Failed to load '+ASSET_PATH+file+' ‚Äî '+e.message); }
  }

  function applyCurrentSelection(){
    const getF = (sel)=> FILAMENTS.find(f=>f.id === sel.value);
    const faceF=getF(faceSel), accentF=getF(accentSel), backerF=getF(backerSel), labelF=getF(labelSel), textF=getF(textSel), accent2F=getF(accent2Sel);

    if (baseRoot){
      if (faceF)   applyFilamentToThree(baseRoot,'Faceplate',faceF);
      if (backerF) applyFilamentToThree(baseRoot,'Backer',backerF);
      if (labelF)  applyFilamentToThree(baseRoot,'Label',labelF);
      if (textF)   applyFilamentToThree(baseRoot,'Text',textF);
    }
    if (accentRoot){
      if (accentF) applyFilamentToThree(accentRoot,'Accent',accentF);
      const warn = (accentStyle.value === 'slat');
      if (accent2F) applyFilamentToThree(accentRoot,'Accent_2',accent2F,{warnIfMissing:warn});
    }
    paintSwatches();
    renderOnce();
    refreshAllBuyButtons();
  }

  // Wire UI
  faceSel.addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  accentSel.addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  backerSel.addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  labelSel .addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  textSel  .addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  accent2Sel.addEventListener('change',()=>{applyCurrentSelection(); refreshAllBuyButtons();});
  accentStyle.addEventListener('change',async()=>{ accent2Wrap.style.display=(accentStyle.value==='slat')?'block':'none'; await loadAccent(accentStyle.value); refreshAllBuyButtons(); updateAccentPrintables(); });

  // Offset + other controls (kept)
  resetBtn?.addEventListener('click', ()=>{ /* no-op now */ });
  copyURL?.addEventListener('click',async()=>{ try{ await navigator.clipboard.writeText(location.href); alert('Link copied!'); }catch(e){} });

  let axesOn=false;
  axesToggleBtn?.addEventListener('click',()=>{
    axesOn=!axesOn;
    if (axesOn){ axesHelper=new THREE.AxesHelper(0.1); scene.add(axesHelper); }
    else { scene.remove(axesHelper); axesHelper=null; }
    renderOnce();
  });
  frameBaseBtn?.addEventListener('click',()=>{ if (baseRoot) fitCameraTo(baseRoot); });
  frameAllBtn?.addEventListener('click',()=>{
    const group=new THREE.Group(); if (baseRoot) group.add(baseRoot.clone()); if (accentRoot) group.add(accentRoot.clone());
    fitCameraTo(group);
  });

  // ResizeObserver sizing (fixes stretch)
  function sizeFromCanvas(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderOnce();
  }
  const ro = new ResizeObserver(sizeFromCanvas);
  ro.observe(canvas);
  window.addEventListener('resize', sizeFromCanvas);

  function renderOnce(){ controls.update(); renderer.render(scene,camera); }
  (function animate(){ requestAnimationFrame(animate); renderOnce(); })();

  // Init
  (async function init(){
    await loadFilaments();      // sets FILAMENTS + window.FILAMENTS, builds selects, attaches pickers
    await loadPresets();        // builds preset chips inside
    if (FILAMENTS.length){
      faceSel.value=FILAMENTS[0].id; accentSel.value=FILAMENTS[2]?.id||FILAMENTS[0].id; backerSel.value=FILAMENTS[1]?.id||FILAMENTS[0].id;
      labelSel.value=FILAMENTS[1]?.id||FILAMENTS[0].id; textSel.value=FILAMENTS[1]?.id||FILAMENTS[0].id; accent2Sel.value=FILAMENTS[3]?.id||FILAMENTS[0].id;
    }
    await loadBase();
    await loadAccent(accentStyle.value);
    applyCurrentSelection();
    sizeFromCanvas();
    if (location.protocol==='file:'){ status('Heads-up: file:// mode. If GLBs fail to show, serve via a local web server.'); }
  })();

  // If script.js loads after this module, attach pickers once more when window finishes loading
  window.addEventListener('load', attachAllPickers);

  /* expose to script.js */
  window.applyCurrentSelection = applyCurrentSelection;
  window.refreshAllBuyButtons  = refreshAllBuyButtons;
</script>



<script src="script.js"></script>
  
</body>
</html>
